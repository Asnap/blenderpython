
#
# This source file is part of appleseed.
# Visit http://appleseedhq.net/ for additional information and resources.
#
# This software is released under the MIT license.
#
# Copyright (c) 2013 Franz Beaune, Joel Daniels, Esteban Tovagliari.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

import bpy
import os
from extensions_framework import util as efutil

def realpath(path):
    return os.path.realpath(efutil.filesystem_path(path))

class MatUtils:
    @staticmethod
    def compute_reflection_factor(material):
        return material.raytrace_mirror.reflect_factor if material.raytrace_mirror.use else 0.0

    @staticmethod
    def is_material_reflective(material):
        return MatUtils.compute_reflection_factor(material) > 0.0

    @staticmethod
    def compute_transparency_factor(material, index):
        layer = material.appleseed.layers[index]
        material_transp_factor = 0.0
        if layer.bsdf_type == "specular_btdf":
            material_transp_factor =  layer.spec_btdf_weight
   
                
        return material_transp_factor

    @staticmethod
    def is_material_transparent(material):
        return MatUtils.compute_transparency_factor(material, index) > 0.0

#--------------------------------------------------------------------------------------------------
# Write a mesh object to disk in Wavefront OBJ format.
#--------------------------------------------------------------------------------------------------

def get_array2_key( v):
    return int( v[0] * 1000000), int( v[1] * 1000000)

def get_vector2_key( v):
    w = v * 1000000
    return int( w.x), int( w.y)

def get_vector3_key( v):
    w = v * 1000000
    return int( w.x), int( w.y), int( w.z)

def write_mesh_to_disk( mesh, mesh_faces, mesh_uvtex, filepath):
    with open( filepath, "w") as output_file:
        # Write file header.
        output_file.write( "# File generated by %s %s.\n" % ( "render_appleseed", "0.1"))

        vertices = mesh.vertices
        faces = mesh_faces
        uvtex = mesh_uvtex
        uvset = uvtex.active.data if uvtex else None

        # Sort the faces by material.
        sorted_faces = [( index, face) for index, face in enumerate(faces)]
        sorted_faces.sort( key = lambda item: item[1].material_index)

        # Write vertices.
        output_file.write( "# %d vertices.\n" % len(vertices))
        for vertex in vertices:
            v = vertex.co
            output_file.write( "v %.15f %.15f %.15f\n" % ( v.x, v.y, v.z))

        # Deduplicate and write normals.
        output_file.write( "# Vertex normals.\n")
        normal_indices = {}
        vertex_normal_indices = {}
        face_normal_indices = {}
        current_normal_index = 0
        for face_index, face in sorted_faces:
            if face.use_smooth:
                for vertex_index in face.vertices:
                    vn = vertices[vertex_index].normal
                    vn_key = get_vector3_key(vn)
                    if vn_key in normal_indices:
                        vertex_normal_indices[vertex_index] = normal_indices[vn_key]
                    else:
                        output_file.write( "vn %.15f %.15f %.15f\n" % ( vn.x, vn.y, vn.z))
                        normal_indices[vn_key] = current_normal_index
                        vertex_normal_indices[vertex_index] = current_normal_index
                        current_normal_index += 1
            else:
                vn = face.normal
                vn_key = get_vector3_key( vn)
                if vn_key in normal_indices:
                    face_normal_indices[face_index] = normal_indices[vn_key]
                else:
                    output_file.write( "vn %.15f %.15f %.15f\n" % ( vn.x, vn.y, vn.z))
                    normal_indices[vn_key] = current_normal_index
                    face_normal_indices[face_index] = current_normal_index
                    current_normal_index += 1

        # Deduplicate and write texture coordinates.
        if uvset:
            output_file.write( "# Texture coordinates.\n")
            vt_indices = {}
            vertex_texcoord_indices = {}
            current_vt_index = 0
            for face_index, face in sorted_faces:
                assert len( uvset[face_index].uv) == len( face.vertices)
                for vt_index, vt in enumerate( uvset[face_index].uv):
                    vertex_index = face.vertices[vt_index]
                    vt_key = get_array2_key( vt)
                    if vt_key in vt_indices:
                        vertex_texcoord_indices[face_index, vertex_index] = vt_indices[vt_key]
                    else:
                        output_file.write( "vt %.15f %.15f\n" % ( vt[0], vt[1]))
                        vt_indices[vt_key] = current_vt_index
                        vertex_texcoord_indices[face_index, vertex_index] = current_vt_index
                        current_vt_index += 1

        mesh_parts = []

        # Write faces.
        output_file.write( "# %d faces.\n" % len(sorted_faces))
        current_material_index = -1
        for face_index, face in sorted_faces:
            if current_material_index != face.material_index:
                current_material_index = face.material_index
                mesh_name = "part_%d" % current_material_index
                mesh_parts.append(( current_material_index, mesh_name))
                output_file.write( "o {0}\n".format(mesh_name))
            line = "f"
            if uvset and len( uvset[face_index].uv) > 0:
                if face.use_smooth:
                    for vertex_index in face.vertices:
                        texcoord_index = vertex_texcoord_indices[face_index, vertex_index]
                        normal_index = vertex_normal_indices[vertex_index]
                        line += " %d/%d/%d" % ( vertex_index + 1, texcoord_index + 1, normal_index + 1)
                else:
                    normal_index = face_normal_indices[face_index]
                    for vertex_index in face.vertices:
                        texcoord_index = vertex_texcoord_indices[face_index, vertex_index]
                        line += " %d/%d/%d" % ( vertex_index + 1, texcoord_index + 1, normal_index + 1)
            else:
                if face.use_smooth:
                    for vertex_index in face.vertices:
                        normal_index = vertex_normal_indices[vertex_index]
                        line += " %d//%d" % ( vertex_index + 1, normal_index + 1)
                else:
                    normal_index = face_normal_indices[face_index]
                    for vertex_index in face.vertices:
                        line += " %d//%d" % ( vertex_index + 1, normal_index + 1)
            output_file.write( line + "\n")

        return mesh_parts
